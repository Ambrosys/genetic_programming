[section Symbolic regression]

The first example is symbolic regression. Symbolic regression can be used to obtain mathematical models from measured data
without a specific a predefined model. Instead one obtains a general "formula" which describes the data. In order to understand 
symbolic regression and how it can be solved with __gpcxx we will create an artificial test data and apply __gpcxx to this data.

[import ../examples/symb_reg/symb_reg.cpp]

First, we create the artifical test data set

[create_training_data]

Here, `regression_training_data<>` is basically a class consisting of one vector ['y] and ['N] vectors ['x].
It is assumed, that an element of ['y] depends on the according ['N] elements of ['x]. Finding this
dependency ['y=f(x[0],x[1],x[2])], hence the function ['f] is the task of the genetic program.

Next, we need to define how the mathematical expression will be represented in our program and how it can be evaluated. Therefore,
we define

[define_tree_types]

The `context_type` is the type which will be passed to the tree and which represent the vector ['x]. It is predefined in __gpcxx, but
it is basically a `std::array< double , 3 >`. To represent the expressions we use the predefine `intrusive_tree<>` class. This
requires that the node type has some specific properties which are all fullfilled by the `basic_named_intrusive_node<>`. In principle,
the implementation of `basic_named_intrusive_node<>` is similar to 

[intrusive_node_implementation]

That is, the node has the following functionality

* It holds a polymorphic function object of type `func_type` performing the actual evaluation of the current node.
* It has a name.
* It can evaluate the context to the current value of the node.

Next, we need to define the set of terminal nodes and the set of function nodes. We start with the terminals. All nodes
enter the program only from 

[define_terminal_set]

[define_function_set]


[endsect]
